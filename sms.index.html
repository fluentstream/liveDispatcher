<html>
    <head>
        <!-- // <script src="lib/socket.io.js"></script> -->
        <script src="https://cdn.socket.io/socket.io-1.3.4.js"></script>
        <script src="config/config.js"></script>
        <script src="liveDispatcher.js"></script>
        <script src="callDispatcher.js"></script>
        <script src="zendeskDispatcher.js"></script>
        <script src="freshdeskDispatcher.js"></script>
        <script src="phoneStatusDispatcher.js"></script>
        <script src="smsDispatcher.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.7.0/underscore-min.js">
            </script>

        <script>

            /*These functions correspond to Socket Events, and thus belong to the parent*/
            function connectEventHandler(event) {
                console.log("Got socket connect event: ", event)
            }
            function reconnectEventHandler(event) {
                console.log("Got socket reconnect event: ", event)
            }
            function reconnectingEventHandler(event) {
                console.log("Got socket reconnecting event. Attempt number ", event)
            }
            function reconnectAttemptEventHandler(event) {
                console.log("Got socket reconnect attempt event.  Attempt number ", event)
            }
            function reconnectErrorEventHandler(event) {
                console.log("Got socket reconnect error event: ", event)
            }
            function reconnectFailedEventHandler(event) {
                console.log("Got socket reconnect failed event")
            }

            /*These functions are for the Call Dispatcher*/
            function messageHandle(event) {
                console.log("Got message event: ", event);
            }

            var options = {
                tenant:"Yahweh",
                eventScope:"tenant",
                extension:"600",
                config:config,
                connectEventHandler:connectEventHandler,
                reconnectEventHandler:reconnectEventHandler,
                reconnectingEventHandler:reconnectingEventHandler,
                reconnectAttemptEventHandler:reconnectAttemptEventHandler,
                reconnectErrorEventHandler:reconnectErrorEventHandler,
                reconnectFailedEventHandler:reconnectFailedEventHandler,
                messageHandle:messageHandle,
                apikey:'NgXvRZP1-9Rc8-93T6-ldxjGHOpQ4x6',
                username:"",
                password:"",
                room:"9703608816"
            };

            var dispatcher = new SmsDispatcher(options);

            dispatcher.run();

            /*This can be used to get all of the calls from the server on an interval*/
            // setInterval(function(){
            //     dispatcher.getState();
            // },60000);

            /*Set up button listeners*/
            // document.addEventListener("DOMContentLoaded", function() {
            //     document.getElementById("getcalls").onclick = function() {
            //         dispatcher.getCalls();
            //     };
            // });

        </script>
    </head>

    <body>
        <p>Testing SMS Dispatcher</p>
        <button type="button" id="getcalls">Get Calls</button>
    </body>

</html>

<!--

The new model for Live Calls (LC) relies on two essential concepts: the bridge and the leg.  
These concepts, each represented in code as objects, together represent a “call”.  Due to 
the wide variety of possible call types (direct, transfers, call groups, call forwarding), 
bridges and legs are created in a variety of ways.  The goal of LC is to insulate you from 
this complexity.  Rather than experiencing the actual events generated by the system as 
calls are made and received, LC presents only the objects that are created.  These objects 
are presented along-side named events, indicating their progress through the life of a call.  

The leg is the most basic element of a call.  When a call is made, two legs are generated: 
one for the caller contacting the phone server, and a second for the phone server 
connecting to the callee.  During the life of a call, more legs can be created.  These can 
represent an added connection to a third caller due to a transfer, or to multiple members 
of a call group.  For most intents and purposes, a leg does little.  They are added and 
removed with little impact on the experience of the phone’s user.  Legs are stored in a 
bridge, the object which is closest to the notion of a “call”.  

The bridge acts as a pool for legs, which exists only as long as it contains legs.  When a 
call is made, a bridge is created with the legs.  The legs are stored inside the bridge.  
As additional legs are created, they can be added to the bridge.  As legs die, they are 
removed.  The call lives and dies with the bridge.  While some types of call forwarding 
require multiple bridges, this should not have a significant effect in your code.  In those 
scenarios, the bridges live simultaneously until one is absorbed into the other.  The 
bridge which is absorbed is destroyed, and the system moves forward. 

The life of a call consists of the following:
    - bridgeCreate: The bridge is created
    - addLeg (x *): Legs are created and added to the bridge (number can vary)
    - callConnect: The caller has connected to the callee (who has picked up)
    - callDisconnect: Either the caller or the callee has disconnected the call.
    - removeLeg (x *): Legs are destroyed. Always equal to the number of addLeg events.
    - bridgeDestroy: Once all legs are destroyed, the bridge is destroyed.

The bridge is created and acts as a pool to store the legs.  The call is connected and 
disconnected, according to the users.  Once the call is finished, legs are destroyed, 
triggering the destruction of the bridge.  Though this order is highly flexible, the bridge 
and leg objects stay true to their functions, and are thus reliable.  

-->
